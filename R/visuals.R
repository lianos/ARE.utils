# palette.two.color <- grDevices::colorRampPalette(c('black','red'))(2)
# palette.two.colorRamp <- grDevices::colorRampPalette(c('black','red'))(256)
# palette.three.color <- grDevices::colorRampPalette(c('green', 'black','red'))(3)
# palette.gr.marray <- grDevices::colorRampPalette(c('green', 'black', 'red'))(256)


# palette.two.color <- gplots::colorpanel(2, low='black', high='red')
# palette.two.colorRamp <- gplots::colorpanel(256, low='black', high='red')
# palette.three.color <- gplots::greenred(3)
# palette.gr.marray <- gplots::greenred(255)
# palette.by.marray <- gplots::colorpanel(255, 'blue', 'black', 'yellow')

palette.gr.marray     <- colorRampPalette(c("green", "black", "red"))


my.image.matrix <- function(m, ...) {
  # Plotting matrices as images is weird ...
  nr <- nrow(m)
  nc <- ncol(m)
  image.default(1:nc, 1:nr, t(m)[, nr:1, drop=FALSE], ...)
}

# image.tf.parents.cexp <- function() {}

## TODO: use sm.densities?
plot.densities <- function(..., along=2, density.params=list(),
                           plot.params=list(), legend=NULL,
                           na.rm=TRUE, main="Densities") {
  # Plot the densities from many examples into one plot.
  # Returns the densities used as a list.
  #
  # WARNING: If you don't explicitly pass in the `along` function, but rather
  #          call `plot.densiteis(data, 'cols')`, this gets hosed
  #
  # ...            : The data to plot the densities for, this can be:
  #                :   - items, to, create, densities, from
  #                :   - a list of densities
  #                :   - a list of numbers
  #                :   - a Nx2 matrix of data, where each row/column is a
  #                :     separate set of observations. Specify which dimension
  #                :     to use by `along`
  # along          : The dimension that holds the data for 1 example.
  #                : 1 is rows, 2 is columns
  # density.params : list of parameters to pass to the `density` function, if we
  #                : have to create densites on the fly. Popular values would be:
  #                :   density.params=list(n=512, kernel='gaussian', na.rm=TRUE)
  #                : Note that passing nothing here will simply use the default
  #                : args
  # plot.params    : like density.params, but for the plot function, you might do
  #                :   plot.params=list(col=rainbow(20), main='Some Title')
  #                : If no `col` is passed, it is autogenerated
  data <- list(...)
  if (all(sapply(data, is, 'density'))) {
    data <- data
  } else if (is.list(data[[1]]) && all(sapply(data[[1]], is, 'density'))) {
    data <- data[[1]]
  } else {
    along <- match.dim(along)
    data <- create.densities(..., along=along, na.rm=na.rm,
                             density.params=density.params)
  }
  stopifnot(is.list(data))
  keep <- sapply(data, is, 'density')
  if (!any(keep)) {
    stop("All items passed in created empty densities")
  }

  data <- data[keep]

  if (is.character(legend) && length(legend) != length(keep)) {
    warning("Number of items in legend is different than number of data points")
    legend <- NULL
  } else {
    legend <- legend[keep]
  }

  col <- rainbow(sum(keep))
  if (is.character(plot.params$col)) {
    if (length(col) != length(keep)) {
      warning("Colors do not match data length, using rainbow")
    } else {
      col <- plot.params$col[keep]
    }
  }
  plot.params$col <- col

  if (is.null(plot.params$ylim)) {
    y.max <- max(unlist(lapply(data, function (d) max(d$y))))
    plot.params$ylim <- c(0, y.max)
  }
  if (is.null(plot.params$xlim)) {
    x.min <- min(unlist(lapply(data, function (d) min(d$x))))
    x.max <- max(unlist(lapply(data, function (d) max(d$x))))
    plot.params$xlim <- c(x.min, x.max)
  }
  if (is.null(plot.params$main)) {
    plot.params$main <- main
  }
  if (is.null(plot.params$ylab)) {
    plot.params$ylab <- "Density"
  }
  if (is.null(plot.params$lwd)) {
    plot.params$lwd <- 2
  }

  do.call(plot, c(list(data[[1]]), plot.params))
  if (length(data) > 1) {
    for (idx in 2:length(data)) {
      rm.params <- c('main', 'xlab', 'ylab')
      line.params <- plot.params[!names(plot.params) %in% rm.params]
      line.params$col <- plot.params$col[idx]
      do.call(lines, c(list(data[[idx]]), line.params))
    }
  }

  if (is.character(legend)) {
    legend('topright', legend=legend, text.col=col)
  }

  invisible(data)
}

add.error.bars <- function(x, y, error, lower=NULL, upper=NULL,
                           width=1/length(x), plot.it=TRUE, ...) {
  ## Plots error bars at x-positions.
  # x             : x-value of observations
  # y             : y-value of observation
  # error         : vector of length(x) of the error at point x
  # upper, lower  : vectors of length(x) indicating a/symmetric errors around
  #               : the observed y-value
  # width         : numeric value indicating the widt of the "caps" of the bars
  # do.plot       : if set to false, you only want to calculate the heights of
  #               : the bars
  # browser()
  if ((missing(error) || is.null(error)) && (is.null(lower) || is.null(upper))) {
    if (is.matrix(y)) {
      error <- sqrt(apply(y, 2, var, na.rm=TRUE) / nrow(y))
      y <- colMeans(y, na.rm=TRUE)
    } else {
      warning("Can't calculate error : only 1 observation / x value")
      error <- rep(0, length(x))
    }
    lower <- y - error
    upper <- y + error
  }

  if (is.null(lower) || is.null(upper)) {
    warning("Can't calculate lower/upper bounds of err at each x")
    lower <- y
    upper <- y
  }

  xlim <- range(x)
  barw <- diff(xlim) * width

  if (plot.it) {
    segments(x, upper, x, lower, ...)
    segments(x - barw, upper, x + barw, upper, ...)
    segments(x - barw, lower, x + barw, lower, ...)
  }

  invisible(list(lower=lower, upper=upper))
}
